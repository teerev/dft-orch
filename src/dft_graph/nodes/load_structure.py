from __future__ import annotations

import json
import shutil
import time
from pathlib import Path
from typing import Any

from ase.io import read as ase_read

from ..config import ConfigLoadError
from ..state import WorkflowState
from ..utils.hashing import sha256_file, sha256_from_obj
from ..utils.logging import log_event
from ..utils.serialization import write_json, write_text

NODE = "load_structure"


def _normalize_float(x: float, digits: int) -> float:
    y = round(float(x), digits)
    # Avoid "-0.0" ending up in JSON/hash/file output
    return 0.0 if y == 0.0 else y


def _canonicalize_atoms(*, atoms: Any, digits: int) -> dict[str, Any]:
    numbers = [int(z) for z in atoms.get_atomic_numbers()]
    symbols = [str(s) for s in atoms.get_chemical_symbols()]

    positions = [
        [_normalize_float(v, digits) for v in row.tolist()] for row in atoms.get_positions()
    ]

    # ASE cell is always present; for non-periodic systems it will be 0s.
    cell = [[_normalize_float(v, digits) for v in row.tolist()] for row in atoms.get_cell().array]

    pbc_raw = atoms.get_pbc()
    pbc = [bool(x) for x in (pbc_raw.tolist() if hasattr(pbc_raw, "tolist") else list(pbc_raw))]

    return {
        "natoms": len(numbers),
        "numbers": numbers,
        "symbols": symbols,
        "positions_A": positions,
        "cell_A": cell,
        "pbc": pbc,
    }


def _render_xyz(*, symbols: list[str], positions: list[list[float]], digits: int) -> str:
    header = [
        str(len(symbols)),
        "canonical.xyz generated by dft_graph (positions in Angstrom)",
    ]
    body = [
        f"{sym} {x:.{digits}f} {y:.{digits}f} {z:.{digits}f}"
        for sym, (x, y, z) in zip(symbols, positions, strict=True)
    ]
    return "\n".join([*header, *body]) + "\n"


def load_structure(state: WorkflowState) -> WorkflowState:
    t0 = time.perf_counter()
    run_dir = Path(state["run_dir"])
    log_path = Path(state["log_path"])
    manifest_path = Path(state["manifest_path"])
    input_dir = run_dir / "input"

    log_event(
        log_path,
        node=NODE,
        event="start",
        structure_path=state.get("structure_path"),
    )

    digits = int((state.get("resolved_config") or {}).get("run", {}).get("precision_digits", 8))

    # Prefer loading from the copied input inside the run dir (artifact discipline).
    structure_input = state.get("structure_input_copied_path")
    structure_resolved = state.get("structure_resolved_path")

    if structure_input:
        src = Path(structure_input)
    elif structure_resolved:
        # If load_config didn't copy for some reason, copy now.
        resolved_path = Path(structure_resolved)
        if not resolved_path.exists():
            raise ConfigLoadError(f"Structure file not found at {resolved_path}")
        dest = input_dir / f"structure{resolved_path.suffix or ''}"
        shutil.copy2(resolved_path, dest)
        src = dest
        state["structure_input_copied_path"] = str(dest)
    else:
        raise ConfigLoadError(
            "No structure configured. Set `structure.path` in YAML or pass `--structure`."
        )

    if not src.exists():
        raise ConfigLoadError(f"Structure file not found at {src}")

    # Ensure we have an input hash (sha256 of copied input)
    if state.get("structure_input_hash") is None:
        state["structure_input_hash"] = sha256_file(src)[:16]

    try:
        atoms = ase_read(str(src), index=0)
    except Exception as e:
        log_event(
            log_path,
            node=NODE,
            event="error",
            message="Failed to load structure via ASE",
            structure_path=str(src),
            error=str(e),
        )
        raise ConfigLoadError(f"ASE failed to read structure file at {src}: {e}") from e

    canonical = _canonicalize_atoms(atoms=atoms, digits=digits)
    structure_hash = sha256_from_obj(canonical)

    canonical_path = input_dir / "canonical.xyz"
    write_text(
        canonical_path,
        _render_xyz(
            symbols=canonical["symbols"],
            positions=canonical["positions_A"],
            digits=digits,
        ),
    )

    state["structure"] = canonical
    state["structure_hash"] = structure_hash
    state["structure_canonical_path"] = str(canonical_path)

    log_event(
        log_path,
        node=NODE,
        event="info",
        message="Loaded structure + wrote canonical export",
        structure_input_path=str(src),
        structure_input_hash=state.get("structure_input_hash"),
        structure_hash=structure_hash,
        natoms=canonical["natoms"],
        canonical_path=str(canonical_path),
    )

    # Update manifest with structure provenance + canonical hash
    try:
        manifest = json.loads(manifest_path.read_text(encoding="utf-8"))
    except Exception:
        manifest = {}
    manifest.setdefault("structure", {})
    manifest["structure"].update(
        {
            "resolved_path": state.get("structure_resolved_path"),
            "input_hash": state.get("structure_input_hash"),
            "copied_path": state.get("structure_input_copied_path"),
            "canonical_hash": structure_hash,
            "canonical_path": str(canonical_path),
            "canonical": canonical,
        }
    )
    write_json(manifest_path, manifest)

    log_event(
        log_path,
        node=NODE,
        event="end",
        duration_s=round(time.perf_counter() - t0, 6),
    )
    return state
